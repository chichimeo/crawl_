package malware

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"regexp"

	"sync"

	"github.com/BurntSushi/toml"
	"gopkg.in/mgo.v2"
)

type Session struct {
	session *mgo.Session
}

type Config struct {
	Hosts      string
	Database   string
	UserName   string
	Password   string
	Collection string
}

var (
	regexLineBreak = regexp.MustCompile(`.*\n`)
	regexString    = regexp.MustCompile(`\S+`)
	regexDay       = regexp.MustCompile(`\d{4}-\d{2}-\d{2}/`)
	collection     *mgo.Collection
)

const (
	urlGetData = "https://malshare.com/daily/%s"
	urlDay     = "%smalshare_fileList.%s.all.txt"
)

func NewSession(conf Config) (*Session, error) {
	dialInfo := &mgo.DialInfo{
		Addrs:    []string{conf.Hosts},
		Database: conf.Database,
		Username: conf.UserName,
		Password: conf.Password,
	}
	session, err := mgo.DialWithInfo(dialInfo)
	if err != nil {
		return &Session{session}, err
	}
	session.SetMode(mgo.Monotonic, true)

	return &Session{session}, nil
}

func (s *Session) Copy() *mgo.Session {
	return s.session.Copy()
}
func (s *Session) Close() {
	if s.session != nil {
		s.session.Close()
	}
}

func NewCollection() (collection *mgo.Collection, close func()) {
	var conf Config
	_, err := toml.DecodeFile("config_example.toml", &conf)
	if err != nil {
		fmt.Println(err)
		return nil, close
	}

	session, err := NewSession(conf)
	close = session.Close

	if err != nil {
		fmt.Println(err)
		return nil, close
	}
	return session.Copy().DB(conf.Database).C(conf.Collection), close
}

func GetAllDays(s string) []string {
	item := regexDay.FindAllString(s, -1)
	keys := make(map[string]bool)
	var list []string
	for _, entry := range item {
		if _, value := keys[entry]; !value {
			keys[entry] = true
			list = append(list, entry)
		}
	}
	return list
}
func GetData(s string) (string, error) {
	resp, err := http.Get(fmt.Sprintf(urlGetData, s))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		return "", err
	}
	return string(body), nil
}
func GetMalware(wg *sync.WaitGroup, allDays <-chan string) {
	defer wg.Done()
	for day := range allDays {
		url := fmt.Sprintf(urlDay, day, day[:len(day)-1])
		body, err := GetData(url)
		if err != nil {
			fmt.Println("error", err)
			continue
		}

		elements := regexLineBreak.FindAllString(body, -1)

		for _, el := range elements {
			item := regexString.FindAllString(el, -1)

			it := Malware{}
			if len(item) < 3 {
				continue
			}
			if item[0] != "NULL" {
				it.Md5 = item[0]
			}
			if item[1] != "NULL" {
				it.Sha1 = item[1]
			}
			if item[2] != "NULL" {
				it.Sha256 = item[2]
			}
			it.Date = day[:len(day)-1]
			err = InsertValue(it)
			if err != nil {
				fmt.Println("error", err)
			}
		}
	}
}

func InsertValue(mal Malware) error {
	err := collection.Insert(mal)
	if err != nil {
		return err
	}
	return nil
}

func Crawl(col *mgo.Collection) {
	collection = col
	body, err := GetData("")
	if err != nil {
		return
	}

	allDays := GetAllDays(body)
	jobs := make(chan string)
	var wg sync.WaitGroup
	for i := 0; i < 100; i++ {
		wg.Add(1)
		go GetMalware(&wg, jobs)
	}
	for _, element := range allDays {
		jobs <- element
	}
	close(jobs)
	wg.Wait()
}
